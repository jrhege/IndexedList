""" Holds tests on search an IndexedList without lookups """

import itertools

import pytest

from indexedlist import IndexedList, Indexable
from indexedlist.exc import SkipItem


@pytest.fixture(scope="module")
def unique_integers():
    """ IndexedList of integers between 1 and 100 """

    return IndexedList(range(1, 101))


@pytest.fixture(scope="module")
def unique_strings():
    """ IndexedList of strings of unique lengths """

    strings = ("z" * i for i in range(1, 101))

    return IndexedList(strings)


@pytest.fixture(scope="module")
def integers_with_nones():
    """ IndexedList of integers with Nones included """

    return IndexedList([1, 2, None, 3, None, 2, 2, None])


@pytest.fixture(scope="module")
def dicts():
    """ IndexedList of dicts """

    a_values = itertools.cycle([1, 2, 3])
    b_values = itertools.cycle([3, 4, 5, 6])

    data = [
        {
            "a": next(a_values),
            "b": next(b_values)
        }
        for _ in range(0, 10)
    ]

    del a_values
    del b_values

    return IndexedList(data)


@pytest.fixture(scope="module")
def repeating_integers():
    """ IndexedList of integers in a repeating pattern """

    values = itertools.cycle(range(1, 8))
    data = [next(values) for _ in range(0, 20)]

    ilist = IndexedList(data)

    return ilist


class TestPlans:
    """ Tests plan creation for searches against IndexedLists with no lookups """

    def test_equality(self, unique_integers):
        """ Test plans generated by equality expression """

        expected = "{'query': 'item == 12', 'operations': [{'operation': 'DataScan'}]}"
        found = str(unique_integers.plan(unique_integers.item == 12))

        assert expected == found, "Plans did not match"

    def test_in_(self, unique_integers):
        """ Test plans generated by in_ expression """

        expected = "{'query': 'item.in_(12, 13)', 'operations': [{'operation': 'DataScan'}]}"
        found = str(unique_integers.plan(unique_integers.item.in_(12, 13)))

        assert expected == found, "Plans did not match"


class TestResults:
    """ Tests results for data seeks """

    def test_equality(self, unique_integers):
        """ Test results of an equality search """

        expected = [(11, 12)]
        found = list(unique_integers.search(unique_integers.item == 12))

        assert expected == found, "Results did not match"

    def test_equality_no_matches(self, unique_integers):
        """ Test given an equals clause that does not match any items """

        expected = []
        found = list(unique_integers.search(unique_integers.item == 101))

        assert expected == found, "Results did not match"

    def test_equality_with_none(self, integers_with_nones):
        """ Test retrieving None via equality """

        expected = [(2, None), (4, None), (7, None)]

        search = integers_with_nones.search(
            integers_with_nones.item == None
        )

        assert expected == list(search), "Results did not match"

    def test_in_(self, unique_integers):
        """ Tests results of an in_ search """

        expected = [(0, 1), (99, 100)]
        found = list(unique_integers.search(unique_integers.item.in_(1, 100)))

        assert expected == found, "Results did not match"

    def test_in_no_matches(self, unique_integers):
        """ Test given an in_ clause that does not match any items """

        expected = []
        found = list(unique_integers.search(unique_integers.item.in_(0, 101)))

        assert expected == found, "Results did not match"

    def test_in_with_none(self, integers_with_nones):
        """ Test retrieving Nones and non-Nones together """

        expected = [(2, None), (3, 3), (4, None), (7, None)]

        search = integers_with_nones.search(
            integers_with_nones.item.in_(3, None)
        )

        assert expected == list(search), "Results did not match"

    def test_single_custom_func(self, unique_strings):
        """ Test applying a single custom function """

        @Indexable
        def item_length(x):
            return len(x)

        expected = [(2, "zzz"), (8, "zzzzzzzzz")]

        search = unique_strings.search(
            item_length(unique_strings.item).in_(3, 9)
        )

        assert expected == list(search), "Results did not match"

    def test_multi_custom_func(self, unique_integers):
        """ Test applying multiple custom functions """

        @Indexable
        def double(x):
            return x * 2

        expected = [(4, 5), (6, 7), (99, 100)]

        search = unique_integers.search(
            double(double(double(unique_integers.item))).in_(40, 56, 800)
        )

        assert expected == list(search), "Results did not match"

    def test_dict_lookup(self, dicts):
        """ Test looking up fields in a dict """

        expected = [
            (2, {'a': 3, 'b': 5}),
            (5, {'a': 3, 'b': 4}),
            (8, {'a': 3, 'b': 3})
        ]

        search = dicts.search(
            dicts.item["a"] == 3
        )

        assert expected == list(search), "Results did not match"

    def test_dict_lookup_after_function(self, dicts):
        """ Test retrieving dict field after passing through a function """

        @Indexable
        def reset_a(x):

            if x["a"] == x["b"]:
                return {"a": None, "b": x["b"]}
            else:
                return x

        expected = [
            (2, {'a': 3, 'b': 5}),
            (5, {'a': 3, 'b': 4})
        ]

        search = dicts.search(
            reset_a(dicts.item)["a"] == 3
        )

        assert expected == list(search), "Results did not match"

    def test_skip_item(self, integers_with_nones):
        """ Test searching using a function that skips evens """

        @Indexable
        def skip_evens(x):

            try:
                if x % 2 == 0:
                    raise SkipItem()
            except TypeError:
                pass

            return x

        expected = [
            (0, 1),
            (2, None),
            (3, 3),
            (4, None),
            (7, None)
        ]

        search = integers_with_nones.search(
            skip_evens(integers_with_nones.item)
        )

        assert expected == list(search), "Results did not match"

    def test_greater_than(self, repeating_integers):
        """ Test searching using > """

        expected = [(5, 6), (6, 7), (12, 6), (13, 7), (19, 6)]

        search = repeating_integers.search(repeating_integers.item > 5)

        assert expected == list(search), "Results did not match"

    def test_greater_than_equals(self, repeating_integers):
        """ Test searching using >= """

        expected = [(5, 6), (6, 7), (12, 6), (13, 7), (19, 6)]

        search = repeating_integers.search(repeating_integers.item >= 6)

        assert expected == list(search), "Results did not match"

    def test_less_than(self, repeating_integers):
        """ Test searching using < """

        expected = [(0, 1), (1, 2), (7, 1), (8, 2), (14, 1), (15, 2)]

        search = repeating_integers.search(repeating_integers.item < 3)

        assert expected == list(search), "Results did not match"

    def test_less_than_equals(self, repeating_integers):
        """ Test searching using <= """

        expected = [(0, 1), (1, 2), (7, 1), (8, 2), (14, 1), (15, 2)]

        search = repeating_integers.search(repeating_integers.item <= 2)

        assert expected == list(search), "Results did not match"
