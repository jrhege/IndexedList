""" Core classes used to implement the IndexedList """

import uuid

from typing import Iterable, Generator, List, Callable

from sortedcontainers import SortedDict

from . import comparators as cmps
from . import patterns
from . import exc
from . import plans


class IndexedList:
    """ Represents a list-like object that can support fast searching via lookups

    Supports familiar list methods for iterating, adding and deleting items.

    Use search() to return a generator that retrieves item positions and values.
    search() will utilize any applicable lookups created using the create_lookup() method.
    If no lookups are available that can support the query provided then a full list scan
    will be used.

    Use the IndexedList's .item property to formulate queries. For example, to return all items
    in the list with a value of 2:

        my_list.search(my_list.item == 2)

    Order of items returned by the generator is NOT guaranteed. It is recommended that
    only immutable objects be stored if lookups will be used (unless the application
    ensures their values do not change).
    """

    def __init__(self, items=None):
        """ Construct a new IndexedList

        :param items: Items to add to list
        """

        # Holds any lookups that have been created for the IndexedList,
        # keyed by lookup name
        self.lookups = {}

        # Holds the actual items provided
        self._data = []

        if items:
            self._add_items(items)

    def __iter__(self):

        return iter(self._data)

    def __len__(self):

        return len(self._data)

    def __setitem__(self, key, value):

        # TODO: Restore lookups to previous state if an error is raised anywhere here
        # Add the new items to lookups
        self._add_to_lookups(value, key)

        # Remove the old item from any lookups
        previous_item = self._data[key]
        self._delete_from_lookups(previous_item, key)

        # Add the new item to the position
        self._data[key] = value

    def __getitem__(self, item):

        return self._data[item]

    def __repr__(self):

        return f"IndexedList({self._data})"

    def __delitem__(self, key):

        self._remove_by_index(key)

    def append(self, object: object):
        """ Append an object to the list

        :param object: Object to append
        """

        self._add_items((object,))

    def create_lookup(self, definition: object = None, name: str = None):
        """ Create a lookup for faster searching

        :param definition: Definition of how and which values get stored in the lookup
            Generally, this will be either None (so create a lookup of all
            values in the list) or an expression using the .item property,
            like my_list.item or my_list.item["b"]. Can also be a search query
            if you want to create filtered lookup (i.e. my_list.item > 100).

        :param name: Name of the index, or None for an autogenerated name
        """

        # If no definition is provided, just add all items in the list to the lookup
        # exactly how they appear.
        if definition is None:
            pattern = patterns.IndexerPattern(TransformationCollection())
        elif isinstance(definition, ItemProxy):
            pattern = definition.pattern
        else:
            pattern = definition

        # Construct the new lookup
        new_lookup = Lookup(
            pattern=pattern,
            name=name
        )

        # Add all existing data to the lookup
        self._rebuild_lookup_data(new_lookup)

        # Save the lookup to our dict of eligible lookups
        self.lookups[new_lookup.name] = new_lookup

    def extend(self, iterable: Iterable):
        """ Add all items from an iterable to the list

        :param iterable: Iterable of items to add to the list
        """

        self._add_items(iterable)

    def search(self, query: ["ItemProxy", patterns.SearchPattern]) -> Generator[tuple, None, None]:
        """ Search for items and return their indices and values

        Construct queries using .item in the following manner (where my_list is your
        IndexedList object):

            results = my_list.search(my_list.item == 100)
            results = my_list.search(my_list.item > 100)
            results = my_list.search(my_list.item.in_(1, 2, 3))

        Order of items returned is not guaranteed.

        :param query: ItemProxy or SearchPattern representing the query to execute
        """

        return self.plan(query).execute(self)

    def plan(self, query: ["ItemProxy", patterns.SearchPattern]) -> plans.QueryPlan:
        """ Construct a query plan that dictates how the search will be conducted

        Construct queries using .item in the following manner (where my_list is your
        IndexedList object):

            results = my_list.search(my_list.item == 100)
            results = my_list.search(my_list.item > 100)
            results = my_list.search(my_list.item.in_(1, 2, 3))

        :param query: ItemProxy or SearchPattern representing the query to plan
        """

        lookups = self.lookups.values()

        return plans.create(
            query=query,
            lookups=lookups
        )

    def _remove_by_index(self, index: int):
        """ Delete an item at a given list index

        :param index: Numeric index of item to delete
        """

        # Get the current value of item at that index
        item = self._data[index]

        # Remove the item and index from all lookups
        self._delete_from_lookups(item, index)

        # Remove the item from the underlying data list
        del self._data[index]

    def _delete_from_lookups(self, item: object, index: int):
        """ Remove an item at a position from all lookups

        :param item: Value of item to remove
        :param index: Numeric index of value to remove
        """

        for lookup in self.lookups.values():
            lookup.remove_item(item, index)

    def _add_items(self, items: Iterable):
        """ Add an iterable of items to the list

        :param items: Iterable of items to add to the list
        """

        # Get the index of the first new item
        index = len(self._data)

        # Add the items to the list
        self._data.extend(items)

        # End here if there are no lookups to update
        if not self.lookups:
            return

        # Add each item to all attached lookups
        for item in items:
            self._add_to_lookups(item, index)

            index += 1

    def _add_to_lookups(self, item: object, index: int):
        """ Add an item to all lookups

        :param item: Value of item to add to lookups
        :param index: Numeric position of item in data list
        """

        for lookup in self.lookups.values():
            lookup.add_item(item, index)

    def _rebuild_lookup_data(self, lookup: "Lookup"):
        """ Rebuild a lookup from data currently in the data list

        :param lookup: Lookup object to rebuild
        """

        for index, item in enumerate(self._data):

            try:
                lookup.add_item(item, index)
            except exc.SkipItem:
                continue

    @property
    def item(self) -> "ItemProxy":
        """ Returns an ItemProxy suitable for constructing queries and lookup definitions """

        return ItemProxy()


class Lookup:
    """ A lookup for quickly finding the index of items in an IndexedList """

    def __init__(self, pattern: patterns.Pattern, name: str = None):
        """ Construct a new Lookup

        :param pattern: Pattern that dictates items in the lookup
        :param name: Optional name, defaults to a UUID
        """

        # Mapping utilizes a SortedDict to allow for range queries (>, <, etc)
        self.mapping = SortedDict()
        self.pattern = pattern
        self.name = name or str(uuid.uuid4())

    def __str__(self):

        return str(self.pattern)

    def add_item(self, item: object, index: int):
        """ Store an item and its index in the lookup

        :param item: Original item stored in an IndexedList
        :param index: Numerical index of item in associated IndexedList
        """

        # Don't store the item if the lookup's pattern does not match it
        # For example, if the pattern is item > 10, don't store 9
        if self.pattern.matches(item):
            key = self.pattern.transform(item)

            self._add_index(key, index)

    def remove_item(self, item: object, index: int):
        """ Remove an item and its index from the lookup

        :param item: Original item stored in an IndexedList
        :param index: Numerical index of item in associated IndexedList
        """

        if self.pattern.matches(item):
            key = self.pattern.transform(item)

            self._remove_index(key, index)

    def handles(self, pattern: patterns.SearchPattern) -> bool:
        """ Determine if lookup can provide data for a particular search pattern

        :param pattern: Pattern to test for compatibility
        """

        return self.pattern.handles(pattern)

    def _add_index(self, key: object, index: int):
        """ Add a list index to the Lookup mapping at key

        When an item is added to an IndexedList with lookups, the item
        is passed through pattern transformations to generate a key.
        For example, a lookup with the definition of item['a'] would look
        at the 'a' key of whatever item was passed in in order to generate
        a lookup key for that item.

        :param key: Key (transformed item) where index should be added
        :param index: Numeric index linking to an item location in an IndexedList
        """

        # Create the key if it does not already exist
        self.mapping.setdefault(key, set()).add(index)

    def _remove_index(self, key: object, index: int):
        """ Remove a list index from the Lookup mapping at key

        :param key: Key (transformed item) where index should be removed
        :param index: Numeric index linking to an item location in an IndexedList
        """

        index_set = self.mapping[key]

        index_set.discard(index)

        # Remove the key from the mapping if no indices remain associated with it
        if not index_set:
            del self.mapping[key]


class Indexable:
    """ Decorator that allows querying and indexing functions applied to an IndexedList

    Consider the following example:

        @Indexable
        def double_it(x):
            return x * 2

    Using the @Indexable decorator allows us to create lookups on the results of
    that function applied to every item in an IndexedList:

        my_list.create_lookup(double_it(my_list.item))

    Once such a lookup is created, the IndexedList will be able to use that lookup
    should the function be called again in the future during a search:

        my_list.search(double_it(my_list.item))

    Both of these approaches would fail without the decorator, which treats an ItemProxy
    input (mylist.item) differently than other input by using it to build a search
    pattern, rather than evaluating it immediately.
    """

    def __init__(self, func: Callable[[object], object]):
        """ Construct a new Indexable wrapper

        :param func: Function that is being wrapped
        """

        self.func = func

        # Indicates whether this function was defined by an end user
        # to help disambiguate user-defined functions from ones included
        # in this package
        self.user_defined = True

        # Any variables referenced by the function that are not
        # provided as arguments to the function
        self.embedded_args = None

        # Used for generating a string description of the wrapped function
        self.description_prefix = f"{func.__name__}("
        self.description_suffix = ")"

    def __call__(self, item: object):

        # If given an ItemProxy, register this wrapper
        # with the ItemProxy so it knows this function
        # needs to be called on any inputted items
        if isinstance(item, ItemProxy):
            item.transformations.add(self)
            return item
        else:
            return self.func(item)


class TransformationCollection:
    """ Represents a collection of functions that are applied at indexing or query time

    Consider a lookup created with the following definition:

        my_list.create_lookup(my_list.item['a']['b'])

    This will create a TransformationCollection with two functions, one for
    extracting 'a' and one for extracting 'b'. This functions are applied in
    order against each item in the IndexedList to produce the proper keys
    for the lookup.
    """

    def __init__(self, functions: List[Indexable] = None):
        """ Construct a new TransformationCollection

        :param functions: Optional list of functions wrapped with @Indexable
        """

        self._functions = functions or []

    def __str__(self):

        description = "item"

        for func in self._functions:
            description = f"{func.description_prefix}{description}{func.description_suffix}"

        return description

    def add(self, func: Indexable):
        """ Add a new function to the TransformationCollection

        :param func: @Indexable wrapped function to add to TransformationCollection
        """

        self._functions.append(func)

    def apply(self, item: object) -> object:
        """ Chain apply all transformations, in order, against the provided item

        :param item: Initial item to transform
        """

        result = item

        # The result of each function becomes the input to the next function
        for func in self._functions:
            result = func(result)

        return result

    @property
    def signature(self) -> int:
        """ Generate a unique hash signature for this TransformationCollection

        At query time, the signature of the query is compared against the signature
        used to create a lookup to determine if the lookup can support the query.
        If the functions in the query differ from the functions used to create the
        lookup (or if they're applied in different orders) then the lookup cannot be used.
        """

        signature_tuple = tuple(
            (func.user_defined, func.func.__name__, func.embedded_args, position)
            for position, func
            in enumerate(self._functions)
        )

        return hash(signature_tuple)


class ItemProxy:
    """ Generic placeholder for an item in an IndexedList

    Typically an ItemProxy is instantiated using the IndexedList's "item" property.
    For example:

        my_list.search(my_list.item == 10)

    The ItemProxy records all @Indexable functions, key attributes,
    method calls and certain arithmetical operations applied against it. These
    are used to build up a TransformationCollection and construct an appropriate
    comparator object.
    """

    def __init__(self):
        """ Construct a new ItemProxy """

        self.transformations = TransformationCollection()
        self.comparator = None

    def __eq__(self, other):

        self.comparator = cmps.EqualsComparator(other)

        return self

    def __gt__(self, other):

        self.comparator = cmps.GreaterThanComparator(other)

        return self

    def __ge__(self, other):

        self.comparator = cmps.GreaterThanEqualsComparator(other)

        return self

    def __lt__(self, other):

        self.comparator = cmps.LessThanComparator(other)

        return self

    def __le__(self, other):

        self.comparator = cmps.LessThanEqualsComparator(other)

        return self

    def __getitem__(self, item):

        # This function is used to retrieve by list index, dict key,
        # or similar from an object at indexing time.
        @Indexable
        def _get_item(x):

            try:
                return x[item]
            except (KeyError, IndexError):
                raise exc.SkipItem()

        _get_item.user_defined = False
        _get_item.embedded_args = (item,)
        _get_item.description_prefix = ""
        _get_item.description_suffix = f"[{item}]"

        self.transformations.add(_get_item)

        return self

    def in_(self, *values):
        """ Retrieve the specific values requested """

        self.comparator = cmps.InComparator(values)

        return self

    @property
    def pattern(self) -> patterns.Pattern:
        """ Transform the ItemProxy into a SearchPattern or IndexerPattern """

        # A SearchPattern is nothing more than an IndexerPattern with a
        # comparator (==, >, <, etc) applied to it.
        if self.comparator is None:

            return patterns.IndexerPattern(self.transformations)

        else:

            return patterns.SearchPattern(
                transformations=self.transformations,
                comparator=self.comparator
            )
